#!/usr/bin/env bash
#
# Instalador AURORA TUI para Debian ZFS NAS
# Design System v2.0 - Monochromatic Slate
# Baseado no "install-system-mockup-7.sh"
# Desenvolvido - 2026-01-29
#

set -e

# ═══════════════════════════════════════════════════════════════════════════════
# AURORA DESIGN SYSTEM v2.0 - PALETA MONOCROMÁTICA SLATE
# ═══════════════════════════════════════════════════════════════════════════════

# Flag de modo simulação
MOCK_MODE=false

# Variável global para modo de boot (UEFI/BIOS)
BOOT_MODE=""

# Fundos e superfícies
DS_VOID=235      # Profundidade absoluta
DS_DEPTH=237     # Superfície base
DS_ELEVATION=239 # Cards/containers

# Bordas (sutileza progressiva)
DS_WHISPER=240 # Divisores discretos
DS_MIST=243    # Bordas padrão

# Textos (hierarquia de informação)
DS_FOG=245    # Labels secundárias
DS_HAZE=248   # Descrições
DS_CLOUD=250  # Corpo de texto
DS_SILVER=252 # Destaques

# Acentos Slate (matiz principal)
DS_SLATE_DIM=66    # Detalhes técnicos
DS_SLATE=67        # Elementos interativos
DS_SLATE_GLOW=68   # Hover/foco
DS_AURORA_PEAK=153 # Estado ativo (único brilhante)

# Funcionais (uso restrito <5%)
DS_SUCCESS=108 # Sucesso
DS_WARNING=179 # Aviso
DS_ERROR=167   # Erro

# Caracteres UI
UI_H='─'
UI_H_D='═'
UI_ARROW='▶'
UI_BULLET='●'
UI_CHECK='✓'
UI_WARN='⚠'

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURAÇÕES DO POOL
# ═══════════════════════════════════════════════════════════════════════════════

POOL_NAME="zroot"
ZFS_OPTS="-o ashift=12 -O compression=lz4 -O acltype=posixacl -O xattr=sa -O dnodesize=auto -O normalization=formD -O mountpoint=none -O canmount=off -O devices=off"

# ═══════════════════════════════════════════════════════════════════════════════
# COMPONENTES DE UI AURORA v2.0
# ═══════════════════════════════════════════════════════════════════════════════

# Hero header com bordas duplas e identidade premium
hero_header() {
	local title="${1:-AURORA INSTALLER}"
	local subtitle="${2:-Debian ZFS NAS - High Performance Storage}"

	clear
	gum style \
		--foreground $DS_AURORA_PEAK \
		--border-foreground $DS_SLATE \
		--border double \
		--align center \
		--width 60 \
		--margin "1 2" \
		--padding "1 2" \
		"$title" "$subtitle"
}

# Função para simular execução de comandos
run_step_mock() {
	local title="$1"
	local duration="${2:-2}"

	gum spin \
		--spinner minidot \
		--spinner.foreground $DS_SLATE \
		--title "$title" \
		--title.foreground $DS_HAZE \
		-- sleep "$duration"
}

# Separador visual elegante
separator() {
	gum style --foreground $DS_MIST --bold \
		"$(printf "${UI_H}%.0s" $(seq 1 60))"
}

# Header de seção com hierarquia clara
section_header() {
	local title="$1"
	echo ""
	separator
	gum style --foreground $DS_SILVER --bold "  ${UI_ARROW} $title"
	separator
}

# Subheader para agrupamentos
subheader() {
	local text="$1"
	echo ""
	gum style --foreground $DS_HAZE --italic "    ↳ $text"
}

# Card de informação com elevação sutil
info_card() {
	local title="$1"
	shift

	gum style \
		--border-foreground $DS_WHISPER \
		--border normal \
		--padding "1 2" \
		--margin "1 2" \
		"$(gum style --foreground $DS_SLATE_GLOW --bold "$title")" \
		"$(gum style --foreground $DS_MIST "$(printf "${UI_H}%.0s" $(seq 1 40))")" \
		"$@"
}

# Item de lista formatado
list_item() {
	local label="$1"
	local value="$2"
	gum style --width 50 \
		"$(gum style --foreground $DS_HAZE "  ${UI_BULLET} $label:") $(gum style --foreground $DS_SLATE_GLOW --bold "$value")"
}

# Progress bar monocromático sofisticado
progress_bar() {
	local current="$1"
	local total="$2"
	local label="${3:-Processando...}"

	local width=40
	local filled=$((current * width / total))
	local empty=$((width - filled))
	local pct=$((current * 100 / total))

	local bar_filled=$(printf '█%.0s' $(seq 1 $filled))
	local bar_empty=$(printf '░%.0s' $(seq 1 $empty))

	echo ""
	gum style --foreground $DS_SLATE \
		"  [$bar_filled$bar_empty] ${pct}%"
	gum style --foreground $DS_FOG --italic \
		"      ${UI_ARROW} $label"
}

# Status badges
status_ok() {
	gum style --foreground $DS_SUCCESS "  ${UI_CHECK} $1"
}

status_info() {
	gum style --foreground $DS_SLATE_DIM "  ${UI_BULLET} $1"
}

status_warn() {
	gum style --foreground $DS_WARNING "  ${UI_WARN} $1"
}

# Caixa de erro premium
error_box() {
	echo ""
	gum style \
		--foreground $DS_ERROR \
		--border-foreground $DS_ERROR \
		--border double \
		--padding "1 2" \
		--margin "1 2" \
		--align center \
		"${UI_WARN} ERRO" \
		"" \
		"$1"
}

# Caixa de sucesso
success_box() {
	gum style \
		--foreground $DS_SUCCESS \
		--border-foreground $DS_SUCCESS \
		--border double \
		--padding "2 3" \
		--margin "1 2" \
		--align center \
		"$@"
}

# Campo de input estilizado
styled_input() {
	local label="$1"
	local placeholder="$2"
	local value="${3:-}"
	local result=""

	echo ""
	gum style --foreground $DS_CLOUD "$label:"

	if [[ -n "$value" ]]; then
		result=$(gum input \
			--placeholder "$placeholder" \
			--value "$value" \
			--prompt.foreground $DS_SLATE \
			--cursor.foreground $DS_AURORA_PEAK)
	else
		result=$(gum input \
			--placeholder "$placeholder" \
			--prompt.foreground $DS_SLATE \
			--cursor.foreground $DS_AURORA_PEAK)
	fi

	echo "$result"
}

# Seleção de lista estilizada
styled_select() {
	local title="$1"
	shift

	echo ""
	gum style --foreground $DS_CLOUD "$title"
	echo ""

	printf '%s\n' "$@" | gum choose \
		--height 8 \
		--cursor.foreground $DS_AURORA_PEAK \
		--selected.foreground $DS_SILVER
}

# Confirmação estilizada
styled_confirm() {
	local prompt="$1"
	local affirmative="${2:-Prosseguir}"
	local negative="${3:-Cancelar}"

	echo ""
	gum confirm "$prompt" \
		--default=false \
		--affirmative "$affirmative" \
		--negative "$negative" \
		--prompt.foreground "$DS_CLOUD" \
		--selected.background "$DS_SLATE"
}

# Spinner com estilo AURORA
styled_spinner() {
	local title="$1"
	gum spin \
		--spinner minidot \
		--spinner.foreground $DS_SLATE \
		--title "$title" \
		--title.foreground $DS_HAZE \
		-- sleep "${2:-2}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# FLUXO DE INSTALAÇÃO
# ═══════════════════════════════════════════════════════════════════════════════

# TELA 1: Boas-vindas e verificação
show_welcome() {
	hero_header "AURORA INSTALLER" "Debian ZFS NAS - High Performance Storage"

	echo ""
	gum style --foreground $DS_HAZE \
		"  Bem-vindo ao instalador AURORA. Este assistente irá"
	gum style --foreground $DS_HAZE \
		"  guiá-lo através da instalação do Debian com ZFS on Root."

	info_card "Requisitos do Sistema" \
		"  ${UI_BULLET} Modo UEFI" \
		"  ${UI_BULLET} Mínimo 4GB RAM" \
		"  ${UI_BULLET} Disco de 20GB+"

	styled_confirm "Iniciar instalação do sistema?" "Iniciar" "Sair" || exit 0
}

# TELA 2: Verificação de hardware
check_hardware() {
	hero_header
	section_header "Verificação de Hardware"

	status_info "Detectando ambiente de boot..."

	# Detectar modo de boot (BIOS vs UEFI)
	if [ -d /sys/firmware/efi ]; then
		BOOT_MODE="UEFI"
		status_ok "Modo UEFI detectado"
	else
		BOOT_MODE="BIOS"
		status_warn "Modo BIOS/Legacy detectado"
	fi

	styled_spinner "Validando ambiente" 1

	# Verificar módulos ZFS
	if ! modprobe zfs 2>/dev/null; then
		status_warn "Módulos ZFS não carregados automaticamente"
	else
		status_ok "Módulos ZFS disponíveis"
	fi

	# Verificar controladoras de armazenamento
	if [ -d /sys/class/scsi_disk ] || lsblk -d &>/dev/null; then
		status_ok "Controladoras de armazenamento ativas"
	else
		status_warn "Nenhuma controladora detectada"
	fi

	echo ""
	styled_confirm "Prosseguir com a instalação?" "Continuar" "Voltar"
}

# TELA 3: Seleção de disco
select_disk() {
	hero_header
	section_header "Seleção de Disco de Destino"

	echo ""
	gum style --foreground $DS_WARNING --align center \
		"  ${UI_WARN} Atenção: Todos os dados no disco selecionado serão APAGADOS."
	echo ""

	# Detecção real de discos
	DISK_LIST=$(lsblk -dno NAME,SIZE,MODEL | grep -v "loop" | awk '{print $1" ("$2") - "$3}')

	if [ -z "$DISK_LIST" ]; then
		error_box "Nenhum disco encontrado disponível para instalação."
		exit 1
	fi

	subheader "Discos detectados"

	TARGET_SELECTED=$(echo "$DISK_LIST" | gum choose \
		--height 8 \
		--cursor.foreground $DS_AURORA_PEAK \
		--selected.foreground $DS_SILVER)

	TARGET_DISK="/dev/$(echo "$TARGET_SELECTED" | awk '{print $1}')"

	echo ""
	status_ok "Disco selecionado: $TARGET_DISK"
}

# TELA 4: Configuração de usuário
configure_user() {
	hero_header
	section_header "Configuração de Conta de Usuário"

	echo ""
	status_info "Configure as credenciais de acesso administrativo"
	echo ""

	ADM_USER=$(styled_input "Nome de usuário administrador" "ex: admin" "helton")

	section_header "Definição de Senha Segura"

	gum style --foreground $DS_FOG --italic \
		"  A senha definida será utilizada tanto para o usuário"
	gum style --foreground $DS_FOG --italic \
		"  administrador quanto para a conta root do sistema."
	echo ""

	while true; do
		echo ""
		gum style --foreground $DS_CLOUD "Digite a senha:"
		ADM_PASS=$(gum input --password --placeholder "Senha forte" \
			--prompt.foreground $DS_SLATE --cursor.foreground $DS_AURORA_PEAK)

		echo ""
		gum style --foreground $DS_CLOUD "Confirme a senha:"
		CONFIRM_PASS=$(gum input --password --placeholder "Repita a senha" \
			--prompt.foreground $DS_SLATE --cursor.foreground $DS_AURORA_PEAK)

		if [ "$ADM_PASS" = "$CONFIRM_PASS" ] && [ -n "$ADM_PASS" ]; then
			echo ""
			status_ok "Senha definida com sucesso!"
			break
		fi

		echo ""
		gum style --foreground $DS_WARNING \
			"  ${UI_WARN} As senhas não conferem ou estão vazias. Tente novamente."
	done
}

# TELA 5: Configuração de rede
configure_network() {
	hero_header
	section_header "Configuração de Rede"

	echo ""
	status_info "Defina o identificador do sistema na rede"
	echo ""

	HOSTNAME=$(styled_input "Hostname do sistema" "ex: nas-zfs" "aurora-nas")

	echo ""
	status_ok "Hostname configurado: $HOSTNAME"
}

# TELA 6: Resumo e confirmação
show_summary() {
	hero_header
	section_header "Resumo da Instalação"

	echo ""
	gum style --foreground $DS_FOG --italic \
		"  Revise as configurações antes de prosseguir:"
	echo ""

	info_card "Configurações Selecionadas" \
		"$(list_item "Disco de destino" "$TARGET_DISK")" \
		"$(list_item "Tamanho" "$(echo $TARGET_SELECTED | awk -F'[()]' '{print $2}')")" \
		"$(list_item "Usuário admin" "$ADM_USER")" \
		"$(list_item "Hostname" "$HOSTNAME")" \
		"$(list_item "Modo de boot" "$BOOT_MODE")" \
		"$(list_item "Filesystem" "ZFS on Root (ZBM)")" \
		"$(list_item "Pool ZFS" "$POOL_NAME")"

	echo ""
	gum style --foreground $DS_WARNING --align center \
		"  ${UI_WARN} ESTA OPERAÇÃO IRÁ APAGAR TODOS OS DADOS DO DISCO!"
	echo ""

	styled_confirm "Confirmar início da instalação?" "${UI_CHECK} PROSSEGUIR" "${UI_WARN} CANCELAR" || exit 1
}

# TELA 7: Instalação com progresso
run_installation() {
	hero_header
	section_header "Instalação em Andamento"

	echo ""
	gum style --foreground $DS_FOG --italic \
		"  Por favor, aguarde enquanto configuramos o sistema..."
	echo ""

	local total_steps=8
	local current_step=0

	# Step 1: Limpar disco
	((current_step++))
	progress_bar $current_step $total_steps "Limpando disco $TARGET_DISK"
	run_step "Limpando disco $TARGET_DISK..." "wipefs -a $TARGET_DISK && sgdisk --zap-all $TARGET_DISK"
	status_ok "Disco preparado"

	# Step 2: Particionamento condicional (BIOS vs UEFI)
	((current_step++))
	if [ "$BOOT_MODE" = "UEFI" ]; then
		progress_bar $current_step $total_steps "Configurando partições EFI e ZFS"
		run_step "Configurando EFI (512MB)..." "sgdisk -n 1:1M:+512M -t 1:EF00 $TARGET_DISK && mkfs.vfat -F 32 -n EFI ${TARGET_DISK}1"
		status_ok "Partição EFI criada e formatada"
	else
		progress_bar $current_step $total_steps "Configurando partições BIOS e ZFS"
		run_step "Configurando BIOS boot (1MB)..." "sgdisk -n 1:0:+1M -t 1:EF02 $TARGET_DISK"
		status_ok "Partição BIOS boot criada"
	fi

	# Step 3: Pool ZFS
	((current_step++))
	progress_bar $current_step $total_steps "Criando pool ZFS $POOL_NAME"
	run_step "Criando Pool ZFS ($POOL_NAME)..." "sgdisk -n 2:0:0 -t 2:BF01 $TARGET_DISK && partprobe $TARGET_DISK && sleep 2 && zpool create -f $ZFS_OPTS -R /mnt $POOL_NAME ${TARGET_DISK}2"
	subheader "Opções: ashift=12, compression=lz4, acltype=posixacl"
	status_ok "Pool ZFS criado"

	# Step 4: Datasets
	((current_step++))
	progress_bar $current_step $total_steps "Configurando datasets ZFS"
	run_step "Criando Datasets ZFS..." "zfs create -o mountpoint=none $POOL_NAME/ROOT && zfs create -o mountpoint=/ -o canmount=noauto -o org.zfsbootmenu:commandline='quiet splash' $POOL_NAME/ROOT/debian && zfs create -o mountpoint=/home $POOL_NAME/home && zfs create -o mountpoint=/root $POOL_NAME/home/root && zpool set bootfs=$POOL_NAME/ROOT/debian $POOL_NAME"
	status_ok "Datasets configurados"

	# Step 5: Montagem (condicional para BIOS/UEFI)
	((current_step++))
	progress_bar $current_step $total_steps "Montando hierarquia de arquivos"
	run_step "Montando hierarquia ZFS..." "zpool export $POOL_NAME && zpool import -N -R /mnt $POOL_NAME && zfs mount $POOL_NAME/ROOT/debian && zfs mount -a"
	if [ "$BOOT_MODE" = "UEFI" ]; then
		run_step "Montando partição EFI..." "mkdir -p /mnt/boot/efi && mount ${TARGET_DISK}1 /mnt/boot/efi"
	fi
	status_ok "Sistema de arquivos montado"

	# Step 6: Extração do sistema base
	((current_step++))
	progress_bar $current_step $total_steps "Extraindo sistema base (pode demorar)"
	local SQUASHFS="/run/live/medium/live/filesystem.squashfs"
	if [ ! -f "$SQUASHFS" ]; then
		error_box "Imagem SquashFS não encontrada em $SQUASHFS"
		exit 1
	fi
	run_step "Extraindo arquivos para o ZFS..." "unsquashfs -f -d /mnt $SQUASHFS"
	status_ok "Sistema base extraído"

	# Step 7: Configuração do sistema
	((current_step++))
	progress_bar $current_step $total_steps "Aplicando configurações do sistema"

	# Hostname
	echo "$HOSTNAME" >/mnt/etc/hostname
	cat >/mnt/etc/hosts <<EOF
127.0.0.1	localhost
127.0.1.1	$HOSTNAME
EOF
	run_step "Configurando hostname ($HOSTNAME)..." "true"

	# Network
	cat >/mnt/etc/systemd/network/20-wired.network <<EOF
[Match]
Name=e*
[Network]
DHCP=yes
EOF
	run_step "Configurando rede (DHCP)..." "true"

	# Machine ID - limpar para regenerar no chroot
	rm -f /mnt/etc/machine-id /mnt/var/lib/dbus/machine-id
	run_step "Gerando machine-id único..." "true"

	# Fstab (apenas EFI no modo UEFI)
	if [ "$BOOT_MODE" = "UEFI" ]; then
		local EFI_UUID=$(blkid -s UUID -o value "${TARGET_DISK}1")
		cat >/mnt/etc/fstab <<EOF
proc /proc proc defaults 0 0
UUID=$EFI_UUID /boot/efi vfat defaults 0 0
EOF
	else
		cat >/mnt/etc/fstab <<EOF
proc /proc proc defaults 0 0
EOF
	fi

	status_ok "Configurações aplicadas"

	# Step 8: Bootloader condicional (BIOS vs UEFI)
	((current_step++))
	progress_bar $current_step $total_steps "Instalando bootloader"

	if [ "$BOOT_MODE" = "UEFI" ]; then
		# UEFI: ZFSBootMenu EFI
		run_step "Configurando ZFSBootMenu EFI..." "mkdir -p /mnt/boot/efi/EFI/ZBM && cp /usr/local/bin/zfsbootmenu.efi /mnt/boot/efi/EFI/ZBM/zfsbootmenu.efi && mkdir -p /mnt/boot/efi/EFI/BOOT && cp /mnt/boot/efi/EFI/ZBM/zfsbootmenu.efi /mnt/boot/efi/EFI/BOOT/BOOTX64.EFI"
		if command -v efibootmgr &>/dev/null; then
			efibootmgr --create --disk $TARGET_DISK --part 1 --label "ZFSBootMenu" --loader "\EFI\ZBM\zfsbootmenu.efi" 2>/dev/null || true
		fi
		status_ok "Bootloader UEFI instalado"
	else
		# BIOS: syslinux/extlinux
		run_step "Configurando syslinux para BIOS..." "mkdir -p /mnt/boot/syslinux && extlinux --install /mnt/boot/syslinux 2>/dev/null || true"
		if [ -f "/usr/lib/syslinux/mbr.bin" ]; then
			dd if=/usr/lib/syslinux/mbr.bin of=$TARGET_DISK bs=440 count=1 2>/dev/null || true
		elif [ -f "/usr/lib/syslinux/mbr/mbr.bin" ]; then
			dd if=/usr/lib/syslinux/mbr/mbr.bin of=$TARGET_DISK bs=440 count=1 2>/dev/null || true
		fi
		status_ok "Bootloader BIOS instalado"
	fi

	# Finalização no chroot
	section_header "Finalizando Configurações"

	# Bind mounts para chroot
	mount --bind /dev /mnt/dev
	mount --bind /proc /mnt/proc
	mount --bind /sys /mnt/sys

	# Executar comandos finais no chroot
	chroot /mnt /bin/bash <<EOF
# Gerar identificadores únicos
systemd-machine-id-setup
zgenhostid
zpool set cachefile=/etc/zfs/zpool.cache $POOL_NAME
update-initramfs -u -k all

# Criar usuário administrador
useradd -m -s /bin/bash -G sudo "$ADM_USER"
echo "$ADM_USER:$ADM_PASS" | chpasswd
echo "root:$ADM_PASS" | chpasswd

# Remover usuário padrão se existir
if getent passwd user >/dev/null; then userdel -r user; fi
EOF

	status_ok "Sistema finalizado"
}

# TELA 8: Conclusão
show_completion() {
	hero_header

	echo ""
	success_box \
		"${UI_CHECK} INSTALAÇÃO CONCLUÍDA COM SUCESSO!" \
		"" \
		"Sistema AURORA instalado e configurado" \
		"" \
		"Hostname: $HOSTNAME" \
		"Usuário: $ADM_USER" \
		"Disco: $TARGET_DISK" \
		"Modo de boot: $BOOT_MODE" \
		"" \
		"Remova a mídia Live e reinicie o sistema."

	echo ""

	if styled_confirm "Deseja reiniciar agora?" "${UI_CHECK} Reiniciar" "Encerrar"; then
		gum style --foreground $DS_AURORA_PEAK "  Reiniciando sistema..."
		sleep 2
		reboot
	else
		gum style --foreground $DS_SLATE "  Instalador encerrado."
		exit 0
	fi
}

# Função auxiliar para execução de steps (DESATIVADA NO MODO MOCK)
run_step() {
	local title="$1"
	local cmd="$2"

	if [[ "$MOCK_MODE" == true ]]; then
		# Modo simulação - apenas mostra spinner
		gum spin \
			--spinner minidot \
			--spinner.foreground $DS_SLATE \
			--title "$title" \
			--title.foreground $DS_HAZE \
			-- sleep 2
	else
		# Modo real (não utilizado no mockup)
		if ! gum spin \
			--spinner minidot \
			--spinner.foreground $DS_SLATE \
			--title "$title" \
			--title.foreground $DS_HAZE \
			-- bash -c "$cmd"; then
			error_box "Falha ao executar: $title"
			exit 1
		fi
	fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# PONTO DE ENTRADA PRINCIPAL
# ═══════════════════════════════════════════════════════════════════════════════

main() {
	show_welcome
	check_hardware
	select_disk
	configure_user
	configure_network
	show_summary
	run_installation
	show_completion
}

# Executa o instalador
main
